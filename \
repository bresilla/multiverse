#include "multiverse/world.hpp"

namespace mvs {
    namespace utl {
        std::vector<concord::ENU> build_corners(float width, float height) {
            std::vector<concord::ENU> corners;
            corners.push_back(concord::ENU(-width / 2.0f, -height / 2.0f, 0.0f));
            corners.push_back(concord::ENU(width / 2.0f, -height / 2.0f, 0.0f));
            corners.push_back(concord::ENU(width / 2.0f, height / 2.0f, 0.0f));
            corners.push_back(concord::ENU(-width / 2.0f, height / 2.0f, 0.0f));
            corners.push_back(concord::ENU(-width / 2.0f, -height / 2.0f, 0.0f));
            return corners;
        }

        // std::vector<concord::Polygon>

    } // namespace utl
    World::World(std::shared_ptr<rerun::RecordingStream> rec, WorldSettings settings) : settings(settings), rec(rec) {
        init(settings);
    }
    World::~World() { world.reset(); }

    void World::init(WorldSettings settings) {
        settings.apply_gravity = false;
        world = std::make_unique<muli::World>(settings);
        float width = settings.get_size().width;
        float height = settings.get_size().height;

        for (auto corner : utl::build_corners(width, height)) {
            float x = static_cast<float>(corner.x);
            float y = static_cast<float>(corner.y);
            float z = static_cast<float>(corner.z);
            enu_corners_.push_back({x, y, z});
            auto wgs_C = corner.toWGS(settings.get_datum());
            float lat = wgs_C.lat;
            float lon = wgs_C.lon;
            wgs_corners_.push_back({lat, lon});
        }

        // create a grid that goes from -width/2 to width/2 and -height/2 to height/2
        for (int i = -width / 2; i < width / 2; i += settings.get_size().grid_size) {
            for (int j = -height / 2; j < height / 2; j += settings.get_size().grid_size) {
                float x = static_cast<float>(i);
                float y = static_cast<float>(j);
                auto grid_size = settings.get_size().grid_size;
                grid_.push_back({{x, y, 0},
                                 {x + grid_size, y, 0},
                                 {x + grid_size, y + grid_size, 0},
                                 {x, y + grid_size, 0},
                                 {x, y, 0}});
            }
        }
    }
    void World::tick(float dt) {
        world->Step(dt);
        visualize();
    }

    void World::visualize() {
        if (is_visualized_) {
            return;
        }
        auto border__ = rerun::components::LineStrip3D(enu_corners_);
        rec->log_static("border", rerun::LineStrips3D(border__).with_colors({{0, 0, 255}}).with_radii({{0.2f}}));

        auto linestring = rerun::components::GeoLineString::from_lat_lon(wgs_corners_);
        rec->log_static("border", rerun::GeoLineStrings(linestring).with_colors({{0, 0, 255}}).with_radii({{0.2f}}));

        for (unsigned int i = 0; i < grid_.size(); i++) {
            auto grd = rerun::components::LineStrip3D(grid_[i]);
            rec->log_static("grid" + std::to_string(i),
                            rerun::LineStrips3D(grd).with_colors({{255, 0, 0}}).with_radii({{0.01f}}));
        }

        // rec->log("batch", rerun::Boxes3D::from_centers_and_half_sizes(
        //                       {{2.0f, 20.0f, 0.0f}, {-2.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 2.0f}}, {{2.0f, 2.0f, 0.0f}})
        //                       .with_labels({"red", "green", "blue"}));
        is_visualized_ = true;
    }

} // namespace mvs
